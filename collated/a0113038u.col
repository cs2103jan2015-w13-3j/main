//@author: a0113038u



	/**
	 * origin: src\udo\storage\StartTimeComparator.java
	 */

public class StartTimeComparator implements Comparator<Task> {
	@Override
	public int compare(Task task1, Task task2) {
		GregorianCalendar start1 = task1.getStart();
		GregorianCalendar start2 = task2.getStart();
		return start1.compareTo(start2);
	}
}

	// End of segment: src\udo\storage\StartTimeComparator.java





	/**
	 * origin: src\udo\storage\Storage.java
	 */

public class Storage {

	private static final String REGEX_SPACE = "\\s+";
	private static final String REGEX_WILDCARD = "\\*";
	private static final double NEAR_MATCH_RATIO = 3.0;
	private static final double ROUND_UP = 0.4;
	public static final String EOL = System.getProperty("line.separator");

	private static ArrayList<Task> taskList;

	private static Task prevTask;		//store the previous task that was added/modified/deleted
	private static String prevCmd;		//store the previous command excluding display/searching
	private static String lastPath;		//store the current path of json file
	private static String prevPath;		//store the last path used to store json file
	private static ArrayList<Task> copycat;		//store the taskList before delete/marking done multiple tasks
	private static Integer maxId;    		//store current maximum group Id

	/**
	 * Constructor
	 */
	public Storage(){
		initialize();
		readTaskList();
	}
	
	/**
	 * This method provides initialization of some objects
	 */
	private void initialize() {
		taskList = new ArrayList<Task>();
		prevTask = new Task();
		prevCmd = "";
		copycat = new ArrayList<Task>();
	}

	
	/**
	 * @return current path to store json file
	 */
	public String getPath(){
		return new String(lastPath);
	}

	/**
	 * Method performs reading task list from Json file
	 */
	// End of segment: src\udo\storage\Storage.java





	/**
	 * origin: src\udo\storage\Storage.java
	 */

	/** 
	 * Method used to add new task to taskList
	 * @param newTask
	 * @return true if task is successfully added, else false
	 */
	public boolean add(Task newTask) {
		if (newTask == null){
			return false;
		}
		prevTask = newTask;
		prevCmd = "add";
		doAddTask(newTask);
		storeTasks();

		return true;
	}

	private void doAddTask(Task newTask) {
		newTask.setIndex(taskList.size());
		newTask.setGroupId(0);
		taskList.add(newTask);
	}

	/**
	 * Method for adding dummy tasks
	 * @param dummyTasks
	 * @return true if dummy tasks are added, else false
	 */
	public boolean add(List<Task> dummyTasks){
		if (dummyTasks.size() == 0){
			return false;
		}

		updateMaxGroupId();

		maxId++;

		addDummyTasks(dummyTasks);

		storeTasks();
		return true;
	}
	
	/**
	 * Method to store taskList to Json file
	 * @return true if taskList is successfully saved, else false
	 */
	private boolean storeTasks() {
		return JsonProcessor.writeJson(lastPath, taskList);
	}

	/**
	 * Method used to store group ID for dummy tasks and store to json file
	 * @param dummyTasks
	 * @return true if action is successfully done, else false
	 */
	private boolean addDummyTasks(List<Task> dummyTasks) {
		for (int i = 0; i < dummyTasks.size(); i++){
			dummyTasks.get(i).setGroupId(maxId);
			dummyTasks.get(i).setIndex(taskList.size());
			taskList.add(dummyTasks.get(i));

		}
		JsonProcessor.writeJson(lastPath,  taskList);
		return true;
	}

	/**
	 * Method used to get a group ID that is not used by any dummy tasks
	 */
	private void updateMaxGroupId() {
		maxId = 0;
		for (int i = 0; i < taskList.size(); i++){
			if (taskList.get(i).getGroupId() > maxId){
				maxId = taskList.get(i).getGroupId();
			}
		}
	}

	/**
	 * Method to keep a Task with a specified index and 
	 * delete all tasks with same groupID 
	 * @param index
	 * @return true if confirm is done successfully, else false
	 */
	public boolean confirm(Integer index){
		if(!isValidIndex(index)){
			return false;
		}

		Integer groupId = taskList.get(index).getGroupId();
		Task keptTask = taskList.get(index);

		updateMaxGroupId();

		if (groupId == null || groupId < 1 || maxId == 0){
			return false;
		}

		removeUnconfirmedTasks(index, groupId, keptTask);
		storeTasks();
		return true;
	}

	/**
	 * Delete all tasks with same groupID as keptTask,
	 * update keptTask groupID to 0
	 * @param index
	 * @param groupId
	 * @param keptTask
	 */
	private void removeUnconfirmedTasks(Integer index, Integer groupId,
			Task keptTask) {
		for (int i = 0; i < taskList.size(); i++){
			if (taskList.get(i).getGroupId() == groupId && taskList.get(i).getIndex() != index){
				Task lastTask = taskList.get(taskList.size() -1);

				if (lastTask.getGroupId() == groupId && lastTask.getIndex() == index){
					index = i;
				}
				taskList.set(i, lastTask);
				taskList.get(i).setIndex(i);
				taskList.remove(taskList.size()-1);
				i--;
			}
		}
		keptTask.setGroupId(0);
		maxId = 0;
	}

	/**
	 * Method performs delete function, 
	 * swap deleted task with last task on list
	 * @param index
	 * @return true if task is successfully deleted, else false
	 */
	public boolean delete(Integer index){

		if (!isValidIndex(index))
			return false;

		prevTask = taskList.get(index);
		prevCmd = "del";
		swapWithLastTask(index);
		storeTasks();
		return true;
	}

	/**
	 * Method to delete a list of Tasks at the specified indices
	 * @param list of indices
	 * @return true if all the tasks are successfully deleted, else false
	 */
	public boolean delete(List<Integer> indices){
		if (areValidIndices(indices)){
			return false;
		}

		for (int i = 0; i <indices.size(); i++){
			if (!isValidIndex(indices.get(i))){
				return false;
			}
		}

		prevCmd = "mult";
		copycat = Utility.deepCopy(taskList);

		for (int i = 0; i < indices.size(); i ++){
			int index = indices.get(i);
			taskList.set(index, new Task());
		}

		for (int i = 0; i < taskList.size(); i ++){
			if (taskList.get(i).getContent() == null){
				taskList.remove(i);
				i--;
			} else {
				taskList.get(i).setIndex(i);
			}
		}
		storeTasks();
		return true;
	}
	
	//check if list of indices are valid
	private boolean areValidIndices(List<Integer> indices) {
		return indices.size() > taskList.size() || indices.size() == 0;
	}

	//check if an index is valid
	private boolean isValidIndex(Integer index) {
		if(index == null || index < 0||index >= taskList.size()|| taskList.size() == 0)
			return false;
		return true;

	}

	/**
	 * Swap task in specified index with the last task on the list
	 * @param index
	 */
	private void swapWithLastTask(Integer index) {
		if (taskList.size() > 1) {
			taskList.set(index, taskList.get(taskList.size() -1));
			taskList.get(index).setIndex(index);
			taskList.remove(taskList.size()-1);
		} else {
			taskList.clear();
		}
	}

	/**
	 * Method to replace task in specified index with a modified Task
	 * @param index
	 * @param modifiedTask
	 * @return true if task is successfully replaced, else false
	 */
	public boolean modify(Integer index, Task modifiedTask){

		if (!isValidIndex(index)){
			return false;
		}
		prevTask = taskList.get(index);
		prevCmd = "mod";

		doModifyTask(index, modifiedTask);

		storeTasks();
		return true;
	}

	/**
	 * Perform update in modified Task's index and groupID
	 * @param index
	 * @param modifiedTask
	 * @return true if task's index and groupID is updated, else false
	 */
	private boolean doModifyTask(Integer index, Task modifiedTask) {
		modifiedTask.setIndex(index);
		if (modifiedTask.getGroupId() == null){
			modifiedTask.setGroupId(0);
		}
		taskList.set(index, modifiedTask);
		JsonProcessor.writeJson(lastPath,  taskList);
		return true;
	}
	
	/**
	 * Get free time slots from TimeSlots class
	 * @return ArrayList of Task with free time slots
	 */
	public ArrayList<Task> findFreeSlots(){
		TimeSlots timeSlots = new TimeSlots(query());
		return timeSlots.getFreeSlots();
	}

	/**
	 * @return the copy of whole taskList
	 */
	public ArrayList<Task> queryAll(){
		return Utility.deepCopy(taskList);
	}

	/**
	 * @param index
	 * @return a task at specified index
	 */
	public Task query(Integer index){
		if (!isValidIndex(index)){
			return new Task();
		}
		return taskList.get(index).copy();
	}

	/**
	 * @param label
	 * @return the tasks matched the label
	 */
	public ArrayList<Task> query(String label){
		ArrayList<Task> returnList = new ArrayList<Task>();
		if (label != null){
			for(int i=0; i<taskList.size();i++){
				if (taskList.get(i).getLabel().equals(label)){
					returnList.add(taskList.get(i).copy());
				}
			}
		}
		return returnList;
	}
	
	/**
	 * @param priority
	 * @return the tasks matched priority level
	 */
	public ArrayList<Task> query(boolean priority){
		ArrayList<Task> returnList = new ArrayList<Task>();
		for(int i=0; i<taskList.size();i++){
			if (taskList.get(i).getPriority() == priority){
				returnList.add(taskList.get(i).copy());
			}
		}
		return returnList;
	}

	/** 
	 * @param date
	 * @return the tasks matched the date specified
	 */
	public ArrayList<Task> query(GregorianCalendar date){
		ArrayList<Task> returnList = new ArrayList<Task>();
		if (date != null){
			for (int i =0; i < taskList.size(); i++){
				if (taskList.get(i).getTaskType() == Task.TaskType.DEADLINE &&
						isNearDate(date,taskList.get(i).getDeadline())){
					returnList.add(taskList.get(i).copy());
				}
				else if (taskList.get(i).getTaskType() == Task.TaskType.EVENT &&
						isBefore(date,taskList.get(i).getEnd()) &&
						isAfter(date,taskList.get(i).getStart())){
					returnList.add(taskList.get(i).copy());
				}
			}
		}
		return returnList;
	}
	
	/**
	 * @param taskType
	 * @return the tasks matched task type: event/deadline/todo
	 */
	public ArrayList<Task> query(Task.TaskType taskType){
		ArrayList<Task> returnList = new ArrayList<Task>();
		if (taskType != null){
			for (int i = 0; i < taskList.size(); i++) {
				if (taskList.get(i).getTaskType() == taskType) {
					returnList.add(taskList.get(i).copy());
				}
			}
		}
		return returnList;
	}

	/**
	 * @param date1
	 * @param date2
	 * @return true if date2 is within 2 days from date1, else false
	 */
	private boolean isNearDate(GregorianCalendar date1, GregorianCalendar date2){
		if (date1.get(Calendar.YEAR) > date2.get(Calendar.YEAR)){
			return false;
		} else if (date2.get(Calendar.YEAR) - date1.get(Calendar.YEAR) > 1){
			return false;
		} else if (date2.get(Calendar.YEAR) > date1.get(Calendar.YEAR)){
			return ((365 - date1.get(Calendar.DAY_OF_YEAR) + date2.get(Calendar.DAY_OF_YEAR)) <= 2);
		} else {
			return (date2.get(Calendar.DAY_OF_YEAR) - date1.get(Calendar.DAY_OF_YEAR) <= 2
					&& date2.get(Calendar.DAY_OF_YEAR) - date1.get(Calendar.DAY_OF_YEAR) >= 0);
		}
	}
	
	/**
	 * @param date1
	 * @param date2
	 * @return true if date1 occurs same or after date2
	 */
	private boolean isAfter(GregorianCalendar date1, GregorianCalendar date2){
		if (date1.get(Calendar.YEAR) != date2.get(Calendar.YEAR)){
			return date1.get(Calendar.YEAR) > date2.get(Calendar.YEAR);
		}
		return date1.get(Calendar.DAY_OF_YEAR) >= date2.get(Calendar.DAY_OF_YEAR);
	}

	/**
	 * @param date1
	 * @param date2
	 * @return true if date1 occurs same or before date2
	 */
	private boolean isBefore(GregorianCalendar date1, GregorianCalendar date2){
		if (date1.get(Calendar.YEAR) != date2.get(Calendar.YEAR)){
			return date1.get(Calendar.YEAR) < date2.get(Calendar.YEAR);
		}
		return date1.get(Calendar.DAY_OF_YEAR) <= date2.get(Calendar.DAY_OF_YEAR);
	}

	/**
	 * Perform search operation
	 * @param searchedContent
	 * @return the tasks matched searched content
	 */
	public ArrayList<Task> search(String searchedContent){
		ArrayList<Task> returnList = new ArrayList<Task>();
		if (searchedContent != null){

			String searchedAfter = searchedContent.trim().replaceAll(" +", " ").toLowerCase();

			if (isWildCardSearch(searchedAfter)){
				returnList = wildcardSearch(searchedAfter);
			} else{
				returnList = nearMatchSearch(searchedAfter);
			}
		}
		return returnList;
	}

	/**
	 * @param searchedContent
	 * @return true if searchedContent indicates wildcard search, else false
	 */
	private boolean isWildCardSearch(String searchedContent) {
		return (searchedContent.contains("*")) || (searchedContent.contains("?"));
	}

	/**
	 * Perform wild card search
	 * @param searchedContent
	 * @return the tasks matched wild card search
	 */
	public ArrayList<Task> wildcardSearch(String searchedContent){
		ArrayList<Task> returnList = new ArrayList<Task>();
		for (int i = 0; i< taskList.size(); i++){
			if (isWildcardMatched(taskList.get(i).getContent().toLowerCase(),
					searchedContent)){
				returnList.add(taskList.get(i).copy());
			}
		}
		return returnList;
	}

	/**
	 * @param tameStr
	 * @param cardStr
	 * @return true if tameStr is matched wildcard search with cardStr
	 */
	public boolean isWildcardMatched(String tameStr, String cardStr){

		String[] cards = cardStr.split(REGEX_SPACE);
		String[] tame = tameStr.split(REGEX_SPACE);
			
		int j = 0;
		for (int i = 0; i < cards.length; i++){
			if (j == tame.length){
				return false;
			}

			boolean isMatch = true;

			if (!cards[i].contains("*") && !compare(cards[i],tame[j])){
				isMatch = false;
			} else {
				String removedCard[] = cards[i].split(REGEX_WILDCARD);
				String temp = tame[j];
				if (cards[i].charAt(0) != '*'){
					int index = firstIndexOf(temp, removedCard[0]);
					if (index != 0){
						isMatch = false;
					} else {
						temp = temp.substring(removedCard[0].length());
					}
				} 
				if (removedCard.length > 1 && cards[i].charAt(cards[i].length() - 1) !='*'){
					int index = lastIndexOf(temp, removedCard[removedCard.length-1]);
					if (index != temp.length() - removedCard[removedCard.length -1].length()){
						isMatch = false;
					}	
				}
				for (int k = 1; k < removedCard.length; k++){
					if (removedCard[k].length() > 0){
						int index = firstIndexOf(temp, removedCard[k]);
						if (index == -1){
							isMatch = false;
						} else {
							temp = temp.substring(index + removedCard[k].length());
						}
					}
				}
			}
			if (!isMatch){
				i--;
			}
			j++;
		}
		return true;
	}

	/**
	 * Compare 2 strings, with '?' counts as a missing single letter
	 * @param str1
	 * @param str2
	 * @return true if 2 strings are matched, else false
	 */
	public boolean compare(String str1, String str2){
		if (str1.length() != str2.length()){
			return false;
		} else {
			for (int i = 0; i < str1.length(); i++){

				if (str1.charAt(i) != '?' && str1.charAt(i) != str2.charAt(i)){
					return false;
				}
			}
		}
		return true;
	}

	/**
	 * @param str1
	 * @param str2
	 * @return the index of first occurrence of str2 in str1
	 */
	public int firstIndexOf(String str1, String str2){
		for (int i = 0; i <= str1.length() - str2.length(); i++){
			if (compare(str2,str1.substring(i, i + str2.length()))){
				return i;
			}
		}
		return -1;
	}
	
	/**
	 * @param str1
	 * @param str2
	 * @return index of last occurrence of str2 in str1
	 */
	public int lastIndexOf(String str1, String str2){
		if (str1.length() < str2.length()){
			return -1;
		}
		if (compare(str2,str1.substring(str1.length() - str2.length()))){
			return str1.length() - str2.length();
		} else {
			return -1;
		}
	}
	
	/**
	 * Perform near match search using edit distance algorithm
	 * @param searchedContent
	 * @return the tasks that matched near match search
	 */
	public ArrayList<Task> nearMatchSearch(String searchedContent){
		ArrayList<Task> returnList = new ArrayList<Task>();
		for (int i = 0; i < taskList.size(); i++){
			if (isNearMatched(taskList.get(i).getContent().toLowerCase(), searchedContent)){
				returnList.add(taskList.get(i).copy());
			}
		}
		return returnList;
	}

	// find minimum number of 3 integers
	private int minimum(int a, int b, int c) {
		return Math.min(Math.min(a, b), c);
	}

	/**
	 * Check if 2 strings are matched by near match search
	 * @param str1
	 * @param str2
	 * @return true if 2 strings are matched, else false
	 */
	public boolean isNearMatched(String str1, String str2){
		if (findDist(str1,str2) <=( int) (str1.length()/NEAR_MATCH_RATIO + ROUND_UP)){
			return true;
		}
		String[] newStr1 = str1.trim().split(REGEX_SPACE);
		String[] newStr2 = str2.trim().split(REGEX_SPACE);
		if (newStr1.length < newStr2.length){
			return false;
		}
		int str2Index = 0;
		int str1Index = 0;
		while (str2Index < newStr2.length && str1Index < newStr1.length){
			int dist = findDist(newStr1[str1Index],newStr2[str2Index]);
			if (dist <= (int)(newStr1[str1Index].length()/NEAR_MATCH_RATIO + ROUND_UP)){
				str1Index++;
				str2Index++;
			} else {
				str1Index++;
			}
		}
		if (str2Index == newStr2.length){
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Lavenstein's algorithm to find edit distance
	 * @param str1
	 * @param str2
	 * @return distance between 2 strings
	 */
	public int findDist(String str1, String str2) {

		int[][] distance = new int[str2.length() + 1][str1.length() + 1];

		for (int i = 0; i <= str2.length(); i++) {
			distance[i][0] = i;
		}
		for (int j = 1; j <= str1.length(); j++) {
			distance[0][j] = j;
		}
		for (int i = 1; i <= str2.length(); i++) {
			for (int j = 1; j <= str1.length(); j++) {
				distance[i][j] = minimum(
						distance[i - 1][j] + 1,
						distance[i][j - 1] + 1,
						distance[i - 1][j - 1]
								+ ((str1.charAt(j - 1) == str2.charAt(i - 1)) ? 0 : 1));
			}
		}
		return distance[str2.length()][str1.length()];
	}

	/**
	 * Perform change priority of a task at specified index
	 * @param index
	 * @return true if task is successfully changed priority, else false
	 */
	public boolean togglePriority(Integer index){
		if (!isValidIndex(index)){
			return false;
		}
		prevTask = taskList.get(index).copy();
		prevCmd = "mod";
		taskList.get(index).setPriority(!taskList.get(index).getPriority());
		storeTasks();
		return true;
	}

	/**
	 * Perform mark an undone task at specified index as done
	 * @param index
	 * @return true if task is marked as done successfully, else false
	 */
	public boolean markDone(Integer index){
		if (!isValidIndex(index)){
			return false;
		}

		if (!taskList.get(index).isDone()){
			prevTask = taskList.get(index).copy();
			prevCmd = "mod";
			taskList.get(index).setDone();
		} else {
			return false;
		}

		storeTasks();
		return true;
	}
	
	/**
	 * Perform mark as done multiple tasks at specified indices
	 * @param list of indices
	 * @return true if the tasks at indices are marked as done, else false
	 */
	public boolean markDone(List<Integer> indices){
		if (areValidIndices(indices)){
			return false;
		}

		ArrayList<Task> temp = Utility.deepCopy(taskList);

		for (int i = 0; i < indices.size(); i++){
			if (!markDone(indices.get(i))){
				return false;
			}
		}
		copycat = temp;
		prevCmd = "mult";

		storeTasks();
		return true;
	}
	
	/**
	 * Method to retrieve tasks have been done
	 * @return list of done tasks
	 */
	public ArrayList<Task> getDone(){
		ArrayList <Task> doneTasks = new ArrayList<Task>();
		for (int i = 0;i < taskList.size(); i++){
			if (taskList.get(i).isDone()){
				doneTasks.add(taskList.get(i).copy());
			}
		}
		return doneTasks;
	}
	
	/**
	 * Method to retrieve tasks are undone
	 * @return list of undone tasks
	 */
	public ArrayList<Task> query(){
		ArrayList<Task> undoneTasks = new ArrayList<Task>();
		for (int i = 0;i < taskList.size(); i++){
			if (!taskList.get(i).isDone()){
				undoneTasks.add(taskList.get(i).copy());
			}
		}
		return undoneTasks;
	}

	/**
	 * Perform undo operation
	 * @return true if last command is successfully undone, else false
	 */
	public boolean undo(){
		switch(prevCmd){
		case "add":
			undoAdd();
			break;
		case "mod":
			undoModify();
			break;
		case "del":
			undoDelete();
			break;
		case "chDir":
			return undoChDir();
		case "mult":
			undoMultipleTasks();
			break;
		default: return false;
		}
		storeTasks();
		return true;
	}

	/**
	 * Perform undo on delete/mark done multiple tasks
	 */
	private void undoMultipleTasks() {
		prevCmd = "";
		taskList = Utility.deepCopy(copycat);
	}

	/**
	 * Perform undo the modify function
	 */
	private void undoModify() {
		taskList.set(prevTask.getIndex(), prevTask);
		prevCmd = "";
	}

	/**
	 * Perform undo the add function
	 */
	private void undoAdd() {
		taskList.remove(taskList.size() -1);
		prevCmd = "";
	}

	/**
	 * Perform undo the delete function
	 */
	private void undoDelete() {
		prevCmd = "";
		if(taskList.size() ==0 || prevTask.getIndex() == taskList.size()){
			taskList.add(prevTask);
		}
		else {
			Task temp = taskList.get(prevTask.getIndex());
			temp.setIndex(taskList.size());
			taskList.add(temp);
			taskList.set(prevTask.getIndex(), prevTask);
		}
	}
}

	// End of segment: src\udo\storage\Storage.java





	/**
	 * origin: src\udo\storage\Task.java
	 */

public class Task implements Comparable<Task> {
    public static enum TaskType {DEADLINE, EVENT, TODO};

	//class defines Task objects
	private Integer groupId;
    private Integer index;
    private TaskType taskType;
	private String content;
	private String deadline;
	private String start;
	private String end;
	private Integer duration;
	private String reminder;
	private String label;
	private boolean priority;
	private boolean done;

	public Task() {
	    done = false;
	    priority = false;
	}
	
	//constructor
	//The constructor Task(Task.TaskType, String, null, GregorianCalendar, int, GregorianCalendar, String, boolean, boolean)
	public Task(TaskType taskType, String content, GregorianCalendar deadline,
	            GregorianCalendar start, GregorianCalendar end, int duration,
	            GregorianCalendar reminder, String label, boolean priority, boolean done) {
		this.taskType = taskType;
		this.content = content;
		this.deadline = Utility.calendarToString(deadline);
		this.start = Utility.calendarToString(start);
		this.end = Utility.calendarToString(end);
		this.duration = duration;
		this.reminder = Utility.calendarToString(reminder);
		this.label = label;
		this.priority = priority;
		this.done = done;
	}
	
	public Integer getGroupId(){
		return groupId;
	}
	
	public Integer getIndex(){
		return index;
	}
	
	public TaskType getTaskType() {
		return taskType;
	}
	
	public String getContent() {
		return content;
	}
	
	public GregorianCalendar getDeadline() {
	    return Utility.stringToCalendar(deadline);
	}

	public GregorianCalendar getStart() {
		return Utility.stringToCalendar(start);
	}

	public GregorianCalendar getEnd() {
		return Utility.stringToCalendar(end);
	}
	
	public Integer getDuration() {
		return duration;
	}
	
	public GregorianCalendar getReminder() {
		return Utility.stringToCalendar(reminder);
	}
	
	public String getLabel() {
		return label;
	}

	public boolean getPriority() {
		return priority;
	}
	
	public boolean isDone() {
		return done;
	}

	public void setGroupId(Integer groupId){
		this.groupId = groupId;
	}
	
	public void setIndex(Integer index){
		this.index = index;
	}
	
	public void setTaskType(TaskType type) {
		this.taskType = type;
	}
	
	public void setContent(String content) {
		this.content = content;
	}
	
	public void setDeadline(GregorianCalendar deadline) {
	    this.deadline = Utility.calendarToString(deadline);
	}
	
	public void setStart(GregorianCalendar start) {
		this.start = Utility.calendarToString(start);
	}
	
	public void setEnd(GregorianCalendar end) {
		this.end = Utility.calendarToString(end);
	}
	
	public void setDuration(Integer duration) {
		this.duration = duration;
	}
	
	public void setReminder(GregorianCalendar reminder) {
		this.reminder = Utility.calendarToString(reminder);
	}
	
	public void setLabel(String label) {
		this.label = label;
	}
	
	public void setPriority(Boolean priority) {
		this.priority = priority;
	}
	
	public void setDone() {
		this.done = !(this.done);
	}
	
	// End of segment: src\udo\storage\Task.java





	/**
	 * origin: src\udo\storage\TimeSlots.java
	 */

public class TimeSlots {
    private static final String CONTENT_FREE_SLOT = "Free slot";

	private ArrayList<Task> occupiedSlots;
	private ArrayList<Task> freeSlots;
	
	public TimeSlots(){
		occupiedSlots = new ArrayList<Task>();
		freeSlots = new ArrayList<Task>();
	}
	
	public TimeSlots(ArrayList<Task> taskList){
		occupiedSlots = new ArrayList<Task>();
		freeSlots = new ArrayList<Task>();
		
		addEventTasks(taskList);
		
		Collections.sort(occupiedSlots, new StartTimeComparator());
		
		mergeSlots();
		setFreeSlots();
	}

	private void addEventTasks(ArrayList<Task> taskList) {
		for (int i = 0; i < taskList.size(); i++){
			if (taskList.get(i).getTaskType() == TaskType.EVENT){
				occupiedSlots.add(taskList.get(i).copy());
			}
		}
	}

	private void mergeSlots(){
		for (int i = 0; i <occupiedSlots.size() -1; i++){
			if (occupiedSlots.get(i).getEnd().compareTo(occupiedSlots.get(i+1).getStart()) >= 0){
					if(occupiedSlots.get(i).getEnd().compareTo(occupiedSlots.get(i+1).getEnd()) <= 0){
						occupiedSlots.get(i).setEnd(occupiedSlots.get(i+1).getEnd());
					}	
						occupiedSlots.remove(occupiedSlots.get(i+1));
						i--;
			}
		}
	}
	
	private void setFreeSlots(){
		for (int i = 0; i < occupiedSlots.size() -1; i++){
			Task temp = new Task();

			temp.setTaskType(TaskType.EVENT);
			temp.setContent(CONTENT_FREE_SLOT);
			temp.setStart(occupiedSlots.get(i).getEnd());
			temp.setEnd(occupiedSlots.get(i+1).getStart());
			
			temp.setIndex(freeSlots.size());
			freeSlots.add(temp);
		}
	}

	public ArrayList<Task> getOccupiedSlots(){
		return occupiedSlots;
	}
	
	public ArrayList<Task> getFreeSlots(){
		return freeSlots;
	}
}

	// End of segment: src\udo\storage\TimeSlots.java





	/**
	 * origin: src\udo\testdriver\StorageTest.java
	 */

public class StorageTest {

	private static ArrayList<Task> taskList = new ArrayList<Task>();
	private static String storageFile = "task.json";
	private static Storage st;
	
	public void initialize(){
		clearFile(storageFile);
		st = new Storage();
		taskList.clear();
	}
	
	public void clearFile(String fileName) {
		try {
			FileWriter fw = new FileWriter(fileName);
			BufferedWriter bw = new BufferedWriter(fw);
			bw.write("");
			fw.close();
			bw.close();
		} catch (IOException ex){
			ex.printStackTrace();
		}
	}
	
	private void addDummyTasks() {
		Task task1 = new Task(TaskType.TODO, "fighting", null,null, null,
				120, new GregorianCalendar(2011,01,02), "personal", false, false);
		Task task2 = new Task(TaskType.EVENT, "reading books", null, new GregorianCalendar(2006,03,01), new GregorianCalendar(2005,04,01),
				0, null, "leisure", false, false);
		
		ArrayList<Task> temp = new ArrayList<Task>();
		temp.add(task1);
		temp.add(task2);
		st.add(temp);
	}

	@Test
	public void testAdd() {	
		initialize();

		Task task0 = new Task(TaskType.DEADLINE, "meeting", new GregorianCalendar(2005,01,01), null, null,
				0, new GregorianCalendar(2005,01,02), "work",true, false);
		Task task1 = new Task(TaskType.TODO, "fighting", null,null, null,
				120, new GregorianCalendar(2011,01,02), "personal", false, false);
		Task task2 = new Task(TaskType.EVENT, "reading books", null, new GregorianCalendar(2006,03,01), new GregorianCalendar(2005,04,01),
				0, null, "leisure", false, false);

		st.add(task0);
		st.add(task1);
		st.add(task2);
	
		taskList.add(task0);
		taskList.add(task1);
		taskList.add(task2);
		assertEquals(taskList, st.query());  //general case
		Task nullTask = null;
		assertEquals(false , st.add(nullTask));  //return false case
	}
	
	@Test
	public void testDelete() {
		initialize();
		assertEquals(false, st.delete(0));
		st.add(new Task(TaskType.DEADLINE, "meeting", new GregorianCalendar(2005,01,01), null, null,
				0, new GregorianCalendar(2005,01,02), "work",true, false));
		assertEquals(true, st.delete(0));
		assertEquals(0, st.query().size());
	
		Task task0 = new Task(TaskType.DEADLINE, "meeting", new GregorianCalendar(2005,01,01), null, null,
				0, new GregorianCalendar(2005,01,02), "work",true, false);
		Task task1 = new Task(TaskType.TODO, "fighting", null,null, null,
				120, new GregorianCalendar(2011,01,02), "personal", false, false);
		Task task2 = new Task(TaskType.EVENT, "reading books", null, new GregorianCalendar(2006,03,01), new GregorianCalendar(2005,04,01),
				0, null, "leisure", false, false);

		st.add(task0);
		st.add(task1);
		st.add(task2);
		assertEquals(false, st.delete(3));	//case of invalid index
		assertEquals(true, st.delete(0));	//general case
		
		taskList.add(task2);				
		taskList.add(task1);
		assertEquals(taskList, st.query());		//check if deleted task is swapped with last task
	}
	
	@Test
	public void TestDelMult(){
		initialize();
		Task task0 = new Task(TaskType.DEADLINE, "meeting", new GregorianCalendar(2005,01,01), null, null,
				0, new GregorianCalendar(2005,01,02), "work",true, false);
		Task task1 = new Task(TaskType.TODO, "fighting", null,null, null,
				120, new GregorianCalendar(2011,01,02), "personal", false, false);
		Task task2 = new Task(TaskType.EVENT, "reading books", null, new GregorianCalendar(2006,03,01), new GregorianCalendar(2005,04,01),
				0, null, "leisure", false, false);
		assertEquals(false, st.delete(new ArrayList<Integer>())); 		//case of empty list
		assertEquals(false, st.delete(new ArrayList<Integer>(5)));		//case of index out of bound
		ArrayList<Integer> del = new ArrayList<Integer>();
		del.add(null);
		assertEquals(false, st.delete(del)); 			//case of null index
		st.add(task0);
		st.add(task1);
		st.add(task2);
		del.clear();
		del.add(1);
		
		ArrayList<Task> expected = new ArrayList<Task>();
		expected.add(st.query(0));
		expected.add(st.query(2));
		expected.get(1).setIndex(1);
		assertEquals(true, st.delete(del));			// list size =1 
		assertEquals(expected, st.query());			//check list again
		st.add(task1);

		del.clear();
		del.add(1);
		del.add(0);
		
		expected.clear();
		expected.add(st.query(2));
		expected.get(0).setIndex(0);

		assertEquals(true,st.delete(del));		//list size >1
		assertEquals(expected, st.query());			//check list again
		
		st.add(task0);
		st.add(task2);
		del.add(2);
		assertEquals(true, st.delete(del));
		assertEquals(new ArrayList<Task>(), st.query()); 		//case of delete everything
	
		st.add(task0);
		st.add(task1);
		st.add(task2);
		del.clear();
		del.add(0);
		del.add(0);
		expected.clear();
		expected.add(st.query(1));
		expected.add(st.query(2));
		expected.get(0).setIndex(0);
		expected.get(1).setIndex(1);
		assertEquals(true, st.delete(del));		//case of repeated indices
		assertEquals(expected, st.query());
	}
	
	@Test
	public void TestModify(){
		initialize();
		assertEquals(false, st.modify(0, new Task()));		//case of invalid index
		
		Task task0 = new Task(TaskType.DEADLINE, "meeting", new GregorianCalendar(2005,01,01), null, null,
				0, new GregorianCalendar(2005,01,02), "work",true, false);
		Task task1 = new Task(TaskType.TODO, "fighting", null,null, null,
				120, new GregorianCalendar(2011,01,02), "personal", false, false);
		
		st.add(task0);
		assertEquals(true, st.modify(0, task1));		//general case
		taskList.add(task1);
		assertEquals(taskList, st.query());			//check whether task is modified
		
	}

	@Test
	public void TestQuery(){
		initialize();
		assertEquals(new ArrayList<Task>(), st.query());	//case of querying empty taskList
		Task task0 = new Task(TaskType.DEADLINE, "meeting", new GregorianCalendar(2005,01,01), null, null,
				0, new GregorianCalendar(2005,01,02), "work",true, false);
		st.add(task0);
		taskList.add(task0);
		assertEquals(taskList, st.query());		//general case
	
		Task test = st.query(-1);
		test.setIndex(0);
		Task expected = new Task();
		expected.setIndex(0);
		
		assertEquals(expected, test);			//case of querying invalid index task
		assertEquals(task0, st.query(0));		//general case
	}
	
	@Test
	public void TestQueryDate(){
		initialize();
		Task task0 = new Task(TaskType.DEADLINE, "meeting", new GregorianCalendar(2005,0,01), null, null,
				0, new GregorianCalendar(2005,01,02), "work",true, false);
		Task task1 = new Task(TaskType.DEADLINE, "fighting", new GregorianCalendar(2005,0,02),null, null,
				120, new GregorianCalendar(2011,01,02), "personal", false, false);
		Task task2 = new Task(TaskType.DEADLINE, "reading books", new GregorianCalendar(2005,0,05),null, null,
				0, null, "leisure", false, false);
		st.add(task0);
		st.add(task1);
		st.add(task2);
		ArrayList<Task> expected = new ArrayList<Task>();
		expected.add(st.query(0));
		expected.add(st.query(1));
		assertEquals(expected,st.query(new GregorianCalendar(2005,0,01)));		//general case
		assertEquals(expected, st.query(new GregorianCalendar(2004, 11, 30)));	//case of last year search
	}
	@Test
	public void TestUndo(){
		initialize();
		Task task0 = new Task(TaskType.DEADLINE, "meeting", new GregorianCalendar(2005,01,01), null, null,
				0, new GregorianCalendar(2005,01,02), "work",true, false);
		Task task1 = new Task(TaskType.TODO, "fighting", null,null, null,
				120, new GregorianCalendar(2011,01,02), "personal", false, false);
		
		assertEquals(false,st.undo());			//case of undo without any previous command
		st.add(task0);
		assertEquals(true, st.undo());			//case of undo add
		assertEquals(new ArrayList<Task>(), st.query());	//check if taskList is actually undone
		assertEquals(false, st.undo());					//case of undo multiple times
		
		st.add(task0);
		st.modify(0, task1);
		assertEquals(true, st.undo());			//case of undo modify
		taskList.add(task1);
		assertEquals(taskList, st.query());		//check if taskList is actually undone
	
		st.delete(0);
		assertEquals(true, st.undo());			//case of undo delete
		assertEquals(taskList, st.query());		//check if taskList is actually undone
	}

	@Test
	public void TestAddDummy(){
		initialize();
		assertEquals(false, st.add(new ArrayList<Task>()));		//case of return false
	
		addDummyTasks();
		for (int i = 0; i < st.query().size(); i++){
			assertEquals(new Integer(1), st.query(i).getGroupId());		//general case
			assertEquals(new Integer(1), st.query(i).getGroupId());		//general case
		}
	
		addDummyTasks();
		for (int i = 2; i < st.query().size(); i++){
			assertEquals(new Integer(2), st.query(i).getGroupId());		//add another groupID
			assertEquals(new Integer(2), st.query(i).getGroupId());		//add another groupID
		}
	}
	
	@Test
	public void TestConfirm(){
		initialize();
		addDummyTasks();
		
		assertEquals(false, st.confirm(-1));			//case of invalid index

		assertEquals(true, st.confirm(0));				//general case
		Task task1 = new Task(TaskType.TODO, "fighting", null,null, null,
				120, new GregorianCalendar(2011,01,02), "personal", false, false);
		Task task2 = new Task(TaskType.EVENT, "reading books", null, new GregorianCalendar(2006,03,01), new GregorianCalendar(2005,04,01),
				0, null, "leisure", false, false);
		task1.setIndex(0);
		task1.setGroupId(0);
		assertEquals(task1, st.query(0));			//test if task is actually confirmed
	
		addDummyTasks();
		task2.setIndex(2);
		task2.setGroupId(1);
		assertEquals(task2, st.query(2));			//test maximum groupID after confirming a task
		
		assertEquals(false, st.confirm(0));			//case of confirming a group 0 task
		assertEquals(true, st.confirm(2));			//general case
		
		task2.setIndex(1);
		task2.setGroupId(0);
		assertEquals(task2, st.query(1));			//check whether task is confirmed
	}

	@Test
	public void TestFreeSlots(){
		initialize();
		assertEquals(new ArrayList<Task>(), st.findFreeSlots());	//case of no free slot
		Task event1 = new Task(TaskType.EVENT, "reading", null,  new GregorianCalendar(2015,03,24,18,0),  
				new GregorianCalendar(2015,03,24, 21,0), 3, null, "leisure", false, false);
		Task event2 = new Task(TaskType.EVENT, "eating", null,  new GregorianCalendar(2015,03,24,11,0),  
				new GregorianCalendar(2015,03,24, 13,0), 2, null, "leisure", false, false);
		Task event3 = new Task(TaskType.EVENT, "studying", null,  new GregorianCalendar(2015,03,24,13,0),  
				new GregorianCalendar(2015,03,24, 16,0), 3, null, "personal", false, false);
		st.add(event1);
		st.add(event2);
		
		Task expected = new Task();
		expected.setTaskType(TaskType.EVENT);
		expected.setContent("Free slot");
		expected.setIndex(0);
		expected.setStart(new GregorianCalendar(2015,03,24, 13,0));
		expected.setEnd(new GregorianCalendar(2015,03,24,18,0));
		ArrayList<Task> temp = new ArrayList<Task>();
		
		temp.add(expected);
		

		assertEquals(temp, st.findFreeSlots()); 			//general case
		
		st.add(event3);
		expected.setStart(new GregorianCalendar(2015,03,24, 16,0));
		assertEquals(temp, st.findFreeSlots());			//case of adding another event and updating
														//free time slot.
	}

	@Test
	public void testSearch(){
		initialize();
		assertEquals(new ArrayList<Task>(), st.search("anything"));		//case of searching 
																		//a empty list		
		st.add(new Task(TaskType.TODO, "do homework", null, null, null, 
				3, null, null, false, false ));
		st.add(new Task(TaskType.TODO, "reading books", null, null, null, 
				3, null, null, false, false ));
		st.add(new Task(TaskType.TODO, "eating lunch", null, null, null, 
				3, null, null, false, false ));
		st.add(new Task(TaskType.TODO, "eating books", null, null, null, 
				3, null, null, false, false ));
		ArrayList<Task> expected = new ArrayList<Task>();
		
		expected.add(st.query(0));
		
		assertEquals(expected, st.search("do homework"));			//case of exact search
		assertEquals(expected, st.search("DO HOMEwork"));		//case of search ignore case
		assertEquals(expected, st.search("do homeork"));		//case of near match search missing words
		assertEquals(expected, st.search("do homezork"));		//case of near match search changing words
		expected.clear();
		assertEquals(expected, st.search("workhome"));		//case of near match search can't match any results

		expected.add(st.query(1));
		expected.add(st.query(3));
		assertEquals(expected, st.search("eading boos"));			//case of near match search return multiple outputs
		
		expected.clear();
		expected.add(st.query(0));
		
	
		assertEquals(expected, st.search("ho?ework"));		//case of wildcard search with "?" only
		
		assertEquals(expected, st.search("d* *w?r*"));		//case of wildcard search with 
															//both "*" and "?"
		
		assertEquals(expected, st.search("D* *W?r*"));		//case of searching wildcard ignore case
	
		assertEquals(expected, st.search("do         *work")); //case with multiple whitespaces
		
		expected.clear();
		expected.add(st.query(1));
		expected.add(st.query(2));
		expected.add(st.query(3));
		assertEquals(expected, st.search("*ea*"));			//case of wildcard search 															//return multiple outputs
		
	}

	@Test
	public void testDoneMult(){
		initialize();
		Task task0 = new Task(TaskType.DEADLINE, "meeting", new GregorianCalendar(2005,01,01), null, null,
				0, new GregorianCalendar(2005,01,02), "work",true, false);
		Task task1 = new Task(TaskType.TODO, "fighting", null,null, null,
				120, new GregorianCalendar(2011,01,02), "personal", false, false);
		Task task2 = new Task(TaskType.EVENT, "reading books", null, new GregorianCalendar(2006,03,01), new GregorianCalendar(2005,04,01),
				0, null, "leisure", false, false);
		assertEquals(false, st.markDone(new ArrayList<Integer>()));		//case of empty list
		assertEquals(false, st.markDone(new ArrayList<Integer>(5)));	//case of out of bound index
		st.add(task0);
		st.add(task1);
		st.add(task2);
		ArrayList<Integer> done = new ArrayList<Integer>();
		done.add(null);
		assertEquals(false, st.markDone(done)); 		//case of null index
		
		done.clear();
		done.add(1);
		assertEquals(true, st.markDone(done));		//list size =1 
		assertEquals(true, st.query(1).isDone());	//check list
	
		assertEquals(false, st.markDone(done));		//mark done already done
		
		done.clear();
		done.add(2);
		done.add(0);
		assertEquals(true, st.markDone(done));
		for (int i = 0; i < st.query().size(); i++){
			assertEquals(true, st.query(i).isDone());
		}
		
	}
}

	// End of segment: src\udo\testdriver\StorageTest.java





